<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Operadores Bitwise</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how bitwise operators work" />
  <meta name="rh-index-keywords" content="Bitwise Operators" />
  <meta name="search-keywords" content="bitwise,bitwise operators" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Operadores Bitwise e Binários</h1>
  <p>No início da era do computador, o <strong>binário</strong> e o <strong>hexadecimal</strong> eram um modo de vida, provavelmente porque as línguas de alto nível (como o BASIC) eram simplesmente muito lentas para funcionar. Por exemplo, a multiplicação de 32 x 32 pode ter levado vários ciclos de CPU para alcançar o uso do BASIC, mas com o binário é feito como uma única operação em um único ciclo de CPU.</p>
  <p>Hoje em dia, porém, com o poder até mesmo de um PC básico, você não precisa mais se preocupar com isso e pode fazer as coisas do &quot;longo caminho&quot;, uma vez que a velocidade da máquina e sua construção mais complexa de CPU compensará qualquer curta aproximação que esta abordagem tenha. Esta é uma ótima notícia, pois significa que você não precisa mais otimizar cada linha de código que você escreve, mas se este for o caso - você deveria realmente se preocupar com o binário?</p>
  <p>A resposta é definitivamente &quot;sim, você deve&quot;. Embora seja verdade que você ainda pode obter alguns aumentos de velocidade - e às vezes estes podem ser significativos - usar binários e hexadecimal leva a uma melhor compreensão de como a CPU funciona e também pode levar a escrever melhor código, ser capaz de embalar melhor os dados e tornar algumas tarefas muito mais simples. Esta página vai explicar um pouco sobre o que é binário, bem como como ele pode ser usado ao fazer seus jogos.</p>
  <p>Portanto, vejamos primeiro a teoria binária mais básica - como os números são criados. Dê uma olhada nesta tabela:</p>
  <p class="code">000 = 0<br />
    001 = 1<br />
    010 = 2<br />
    100 = 4</p>
  <p>Cada 1 ou 0 representa um único <a class="glossterm" data-glossterm="bit" href="#">bit</a> de dados, e como você pode ver isso significa que em binário, 10 é igual a 2! Cada bit é 2 vezes o valor anterior, sendo o primeiro bit igual a 1. Então bit 2 = 2, bit 3 = 4, bit 4 = 8 e assim por diante (como mostrado abaixo nesta tabela de <a class="glossterm" data-glossterm="byte" href="#">bytes</a> ):</p>
  <p class="code">00000001 = 1<br />
    00000010 = 2<br />
    00000100 = 4<br />
    00001000 = 8<br />
    00010000 = 16<br />
    00100000 = 32<br />
    01000000 = 64<br />
    10000000 = 128</p>
  <p>Tudo bem se você quer números que são um poder de 2, mas como criar números mais complexos? Bem, um único número binário só pode armazenar um 0 ou 1, e é isso, então para números mais complexos precisamos adicionar bits juntos. Se, por exemplo, quiséssemos fazer 6, adicionaríamos 4 e 2 juntos, assim.</p>
  <p class="code">00000010 = 2<br />
    00000100 = 4<br />
    00000110 = 6</p>
  <p>Isto é verdade para <strong>todos os </strong>números <strong>binários </strong>, e como o computador compõe qualquer número internamente. Tomemos um número um pouco mais complicado como mais um exemplo: 23. O número 23 é na verdade composto de <span class="inline">1+2+4+16</span> ou <span class="inline">00010111</span>. Que tal um exemplo muito mais complexo: 196? Bem, isso é feito de <span class="inline">128+64+4</span> ou <span class="inline">11000100</span>. Então, na verdade, não é tão complexo assim!</p>
  <p>Se começarmos a fazer valores fora do intervalo de um byte (que pode armazenar números de 0 a 255), começa a ser um pouco mais difícil de rastrear, no entanto. Por exemplo, 217.361 é <span class="inline">110101000100010001</span> em binário. Ou, <span class="inline">1+16+256+etc...</span> As regras são as mesmas, não importa qual seja o valor expresso - cada número é criado a partir da adição de vários bits juntos.</p>
  <p>Agora, como realizamos operações matemáticas sobre estes valores? Digamos que você queira armazenar <span class="inline">true</span> ou <span class="inline">false</span> como um valor. Normalmente os compiladores usarão um <span class="inline">INT</span> (um <span class="inline">INT</span> é normalmente definido como um número de 32 bits assinado - assinado significa apenas que pode ser um valor positivo ou negativo, enquanto que não assinado significa que só pode ser positivo) e então simplesmente atribuí-lo a <span class="inline">0</span> ou <span class="inline">1</span>. Tendo apenas 2 estados, um valor <span class="inline">true</span> / <span class="inline">false</span> é ideal para armazenar em um bit, e se fizéssemos isso, poderíamos armazenar 32 <span class="inline">true</span> / <span class="inline">false</span> bits para cada <span class="inline">INT</span> em vez de apenas um, já que um <span class="inline">INT</span> é composto de 32 bits.</p>
  <p>Como faríamos isso? Bem, é muito fácil:</p>
  <p class="code">flags = flags | 1;</p>
  <p>O operador &quot;<span class="inline">|</span>&quot; é um pouco <span class="inline">OR</span>, e isso significa a instrução acima <span class="inline">ORs</span> 1 no valor mantido na variável <span class="inline">flags</span>. Se você se lembrar de antes, usando um 1, definirá o primeiro bit. Se quiséssemos definir o segundo bit, o faríamos:</p>
  <p class="code">flags = flags | 2;</p>
  <p>Nós <span class="inline">OR</span> em 2, porque o padrão de bits <span class="inline">00000010</span> é igual a 2. Então o que faz exatamente o operador do binário <span class="inline">OR</span>? Bem, ele funde todos os bits em um único valor, como este:</p>
  <p class="code">010110100 // Value 1<br />
    110011001 // value 2<br />
    110111101 // Value 1 OR Value 2</p>
  <p>Aqui está o que é conhecido como <a class="glossterm" data-glossterm="tabela da verdade" href="#">tabela da verdade</a> para o operador OR:</p>
  <p class="code">00 | 00 = 00<br />
    00 | 01 = 01<br />
    01 | 01 = 01<br />
    01 | 00 = 01</p>
  <p>Assim, onde há um valor com 2 zeros, ele permanecerá zero. A vantagem de usar bits como este como um estado <span class="inline">true</span>/<span class="inline">false</span>, é que eles podem definir vários bits como &quot;bandeiras&quot; em uma operação, algo que você simplesmente não poderia fazer com um valor booleano normal. Por exemplo, digamos que o bit 1 é um &quot;ativo&quot; <span class="notranslate">flag</span>, e o bit 3 é um &quot;visível&quot; <span class="notranslate">flag</span>. Poderíamos definir ambos ao fazer isto:</p>
  <p class="code">flags = flags | 5<span class="inline"></span>;</p>
  <p>Isto porque 5 é <span class="inline">00000101</span> em binário, e seguindo a regra acima, a variável &quot;bandeiras&quot; fará com que ambos os 2 bits se fundam com seus próprios. Portanto, mesmo que o bit 1 já tenha sido definido, a operação ainda funciona e o bit 3 agora também será definido.</p>
  <p>E quanto ao clearing <span class="notranslate">flags</span>? Bem, é aqui que entra a operação bitwise &quot;<span class="inline">&amp;</span>&quot; <span class="inline">AND</span>. Quando você <span class="inline">AND</span> algo, os bits que estão colocados na máscara são mantidos, enquanto os bits que estão claros na máscara, são removidos - assim:</p>
  <p class="code">01110010101 // Value 1<br />
    00110000100 // Value 2<br />
    00110000100 // Value 1 AND value 2</p>
  <p>Como você pode ver, onde há um 1 em cada valor, o 1 é mantido, e onde há uma mistura ou 0's e 1's estes são zerados para 0. Aqui está a tabela da verdade para <span class="inline">AND</span>ing:</p>
  <p class="code">00 &amp; 00 = 00<br />
    01 &amp; 00 = 00<br />
    00 &amp; 01 = 00<br />
    01 &amp; 01 = 01</p>
  <p>Portanto, somente quando há um pouco em cada lugar é que ele será mantido. O que isto significa, é que assim como você é capaz de definir múltiplos <span class="notranslate">flags</span> de uma só vez, você também pode limpar múltiplos <span class="notranslate">flags</span> de uma só vez. Por exemplo, tomemos o caso acima, mas desta vez os esclareça. Queremos limpar os bits 1 e 3 (dando-nos o valor 5), mas ao lembrar a tabela da verdade acima, o que queremos fazer é manter todos os outros bits, e limpar os bits 1 e 3. Esta seria uma &quot;máscara&quot; binária de 111111111111111111111111111111111010 (32bits). Esta máscara mantém todos os bits definidos atualmente, mas limpa os dois bits que realmente queremos que sejam limpos. Portanto, se tivesse um valor de 1000111011 e eu quisesse limpar os bits 1 e 3 usando a máscara acima, acabaria assim...</p>
  <p class="code">00000000000000000000001000111011 // Value<br />
    11111111111111111111111111111010 // Mask<br />
    00000000000000000000001000111010 // Value AND Mask</p>
  <p>Isto é ótimo, mas se tivéssemos que resolver isto toda vez que precisássemos limpar <span class="notranslate">flags</span>, isto se tornaria cansativo. O que precisamos é de uma maneira de virar os bits facilmente (e de preferência sem custo de CPU). Felizmente, há uma maneira fácil de fazer isso usando o operador &quot; <span class="inline">~</span>&quot; <span class="inline">NOT</span>.</p>
  <p>O operador <span class="inline">NOT</span> é apenas o que diz - <em>não</em> esses bits. Aqui está uma tabela da verdade para <span class="inline">NOT</span>.</p>
  <p class="code">~00 = 11<br />
    ~01 = 10<br />
    ~10 = 01<br />
    ~11 = 00</p>
  <p>Este operador torna a remoção do <span class="notranslate">flags</span> muito simples, e melhor ainda, normalmente é uma otimização do tempo de compilação, ou seja, se você estiver usando um número constante (ou seja, não uma variável), então o compilador irá virar os bits automaticamente para você. Pegue esta afirmação onde queremos limpar os bits 1 e 3 novamente:</p>
  <p class="code">a = a &amp; ~5;</p>
  <p>Na verdade, isto se resumirá a apenas &quot;<span class="inline">a &amp; 11111111111111111111111111111010</span>&quot;. Isto torna a vida bastante simples em termos de compensação <span class="notranslate">flags</span>.</p>
  <p>O último operador que queremos ver é &quot;<span class="inline">^</span>&quot; <span class="inline">EOR</span> (<span class="inline">Exclusive OR</span>, às vezes chamado <span class="inline">XOR</span>), este operador inverte os bits definidos em ambos os valores. Aqui está a tabela da verdade em <span class="inline">EOR</span>:</p>
  <p class="code">0 ^ 0 = 0<br />
    0 ^ 1 = 1<br />
    1 ^ 0 = 1<br />
    1 ^ 1 = 0</p>
  <p>Esta é uma curiosidade, mas incrivelmente útil. Por exemplo, digamos que queremos um contador que simplesmente conte de 0 a 1 e volte a 0 (alternando entre 0 e 1), poderíamos adicionar um e fazer um <span class="inline">IF</span> para ver se chegou a 2, e depois redefini-lo de volta a 1. Ou...poderíamos adicionar 1 e depois <span class="inline">AND</span> com 1 (desde <span class="inline">01+01 = 10</span>, e <span class="inline">10 &amp; 01 = 0</span>) ou podemos fazer isso:</p>
  <p class="code">a = a ^ 1;</p>
  <p>O que isto faz a primeira vez que é executado é <span class="inline">0 ^ 1 = 1</span>, depois a segunda vez <span class="inline">1 ^ 1 = 0</span>, alternando assim as coisas de 0 para 1.</p>
  <p>Assim - <span class="inline">OR</span> (<span class="inline">|</span>), <span class="inline">AND</span>(<span class="inline">&amp;</span>), <span class="inline">NOT</span>(<span class="inline">~</span>) e <span class="inline">EOR</span>(<span class="inline">^</span>) vamos manipular bits com relativa facilidade, permitindo-nos, no nível mais simples, controlar vários bits ao mesmo tempo. Obviamente podemos usar estas operações para outras coisas ao desenvolver nossos jogos, como mascarar <span class="notranslate">sprites</span>, fazer operações inteiras <span class="inline">MOD</span> (usando <span class="inline">AND</span>) ou fazer bons contadores de looping.</p>
  <p>Então, podemos fazer operações simples, mas vamos olhar para as coisas mais complexas, começando com a pergunta, como um computador acrescenta? Vejamos um exemplo muito simples: <span class="inline">1+1</span>.</p>
  <p class="code">00000001<br />
    00000001<br />
    00000010</p>
  <p>Assim como as adições normais, adicionamos números juntos e depois transbordamos para a coluna seguinte, mas ao contrário de uma adição decimal normal, só podemos ir de 0 a 1, não de 0 a 9. Portanto, adicionar um <span class="inline">1+1</span> significa que transbordamos para <span class="inline">10</span>. Portanto, vejamos um exemplo mais complexo.</p>
  <p class="code">01011011 = 91<br />
    00101101 = 45<br />
    10001000 = 136</p>
  <p>É obviamente mais difícil ver aqui, mas o transbordamento se estende até que não haja ninguém em uma coluna. Vale notar que os computadores só podem adicionar (ou subtrair, multiplicar ou dividir) 2 números ao mesmo tempo. Pegue <span class="inline">19 + 19 + 19</span>. Sendo humanos, podemos somar todos os 9 juntos, carregar os 2 e depois continuarmos! Mas os computadores não podem fazer isso - o que eles podem fazer é o seguinte:<span class="inline"> (19 + 19) + 19</span>. Portanto, eles farão cada cálculo em blocos de 2.</p>
  <p>Os cálculos binários que mais nos interessam como programadores são a multiplicação e a divisão. Os computadores só se multiplicam em 2s e, para fazer mais, quebra um número e depois adiciona todos os resultados juntos. Vamos tomar alguns exemplos muito simples primeiro. <span class="inline">4 * 2 = 8</span>. Agora, para multiplicar por 2 em binário, <em>deslocamos </em>todos os bits para a ESQUERDA por um. Assim:</p>
  <p class="code">00000100 * 2 = 00001000 = 8</p>
  <p>Todos os bits neste caso se moveram para a esquerda por um, fazendo-o passar do 3º bit, para o 4º, e mudando o valor de 4 para 8. Que tal um número maior?</p>
  <p class="code">101 = 01100101 * 2 = 11001010 = 202</p>
  <p>Mais uma vez, todos os bits se movem em um, e esse múltiplo por 2. Então, que tal um múltiplo por 4? Fácil, nós deslocamos tudo o que sobra por 2, em vez de um. Então, que tal 16, ou 128? Isto exigiria um deslocamento à esquerda de 4 bits, ou 7 bits respectivamente. Isto é incrivelmente útil; significa que podemos fazer multiplicações simples, simplesmente movendo os bits. Para fazer isso, usamos o operador do <strong>turno esquerdo</strong> <span class="inline">&lt;&lt;</span>. Aqui estão alguns exemplos:</p>
  <p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br />
    00000001 &lt;&lt; 2 = 000000100 = 4<br />
    00000001 &lt;&lt; 3 = 000001000 = 8<br />
    00000001 &lt;&lt; 4 = 000010000 = 16<br />
    00000001 &lt;&lt; 5 = 000100000 = 32<br />
    00000001 &lt;&lt; 6 = 001000000 = 64<br />
    00000001 &lt;&lt; 7 = 010000000 = 128<br />
    00000001 &lt;&lt; 8 = 100000000 = 256</p>
  <p>Agora, além de ser muito útil para multiplicações rápidas/simples, também é muito útil para definir bits específicos, sem ter que descobrir o valor do bit. Digamos que queríamos definir o bit 27, que número é esse? (67108864 a propósito!), bem, podemos usar a sintaxe acima para definir facilmente <span class="notranslate">flags</span> desta forma:</p>
  <p class="code">a = a | (1 &lt;&lt; 27)</p>
  <p>Certo... então na verdade este seria o bit 26 da maneira como temos descrito as coisas até agora (como bits têm começado em um), mas na verdade... bits começam no bit 0, e vão para cima, não no bit 1. Assim, enquanto há 32 bits em um INTEGER, os bits variam de 0 a 31, e não de 1 a 32. Isto é realmente muito útil, pois agora podemos estabelecer constantes para os números de bits.</p>
  <p>Então digamos que o bit 27 é um ativo <span class="notranslate">flag</span>, e o bit 0 é um explosivo <span class="notranslate">flag</span>. Como podemos definir ambos?</p>
  <p class="code">ACTIVE = 27;<br />
    BOOM = 0;<br />
    A = A | (1 &lt;&lt; ACTIVE) | (1 &lt;&lt; BOOM);</p>
  <p>Isto pode parecer muito código, mas se estes números forem constantes, o compilador irá pré-compilar estas operações em um único valor para que acabemos com isto como código real.</p>
  <p class="code">A = A | 13421772;</p>
  <p>Limpar estes pedaços (como vimos acima) é simplesmente uma questão de usar o modificador NOT, como este:</p>
  <p class="code">A = A &amp; ~((1 &lt;&lt; ACTIVE) | (1 &lt;&lt; BOOM));</p>
  <p>Assim, isto nos permite, felizmente, definir e limpar quaisquer pedaços que desejarmos, e também nos permite comprimir maciçamente as estruturas de dados. Comprimir estruturas de dados é uma coisa boa, porque se você usa menos memória, você recebe menos <span class="notranslate">cache</span> falhas, e seu código simplesmente corre mais rápido. Colocando desta forma, o que é mais rápido, copiar 32Mb ou dados, ou 4Mb? Bem, muito claramente 4Mb é. Portanto, se você puder embalar todos os seus <span class="notranslate">flags</span> em um único acesso de memória, isto é bom!</p>
  <p>Agora, vamos dar uma rápida olhada em como você faz a divisão e por que ela será tão útil. A divisão é feita deslocando os bits <em>corretamente</em> usando o operador de <strong>turno certo</strong> <span class="inline">&gt;&gt;</span>. Vamos pegar um número simples - 64 - e dividi-lo por 32:</p>
  <p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010</p>
  <p>Então lá você desloca o único bit para baixo em 5 (que é o número de turnos necessários para 32 - veja acima), o que nos dá 2. Mas o que acontece se houver outros bits aqui dentro? Bem, vamos dar uma olhada:</p>
  <p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010</p>
  <p>Então lá vai você.... É exatamente o mesmo. Os bits que deslocamos para baixo são simplesmente perdidos. Isto é realmente útil, porque ao dividirmos se precisarmos do restante, há uma maneira ainda mais fácil de obtê-lo, a qual chegaremos em um momento. Mas antes, vamos dar um exemplo prático. Eu tenho uma posição X e Y, e quero conseguir que a quadrícula da grade caia dentro, onde a grade tem 32x32 de tamanho. Este método permite armazenar <span class="notranslate">objects</span>, colisões, <span class="notranslate">flags</span> - todo tipo de coisas, e acessá-las muito rapidamente. Portanto, aqui vamos nós:</p>
  <p class="code">var X_index = x &gt;&gt; 5;<br />
    var Y_index = y &gt;&gt; 5;<br />
    cell_data = mygrid[# X_index,Y_index];</p>
  <p>Então, e se quiséssemos o restante? Talvez este restante seja usado como algum tipo de ordem <span class="notranslate">flag</span> ou algo assim. Seja qual for o motivo, conseguir um resto é tão simples quanto fazer um <span class="inline">AND</span>:</p>
  <p class="code">var remainder = x &amp; 31<br />
    var X_Index = x &gt;&gt; 5;</p>
  <p>Agora, você deve ter notado que usamos várias linhas de código aqui (como é tão freqüentemente o caso), mas isto ainda é apenas um par de instruções muito rápidas. Mas por que o 31? Bem, como o bit 5 é 32, então todos os bits abaixo seriam 31, e esse é o máximo restante, então é com isso que nós <span class="inline">AND</span> (poderíamos também usar <span class="inline">(1 &lt;&lt; 5) - 1</span> que faria <span class="inline">32 - 1 = 31</span>). Agora, se eu fizesse isso sem entender o binário, pareceria assim:</p>
  <p class="code">var r = x mod 32;<br />
    var X_Index = floor(x / 32);</p>
  <p>Então por que isso é muito pior? Bem, para dividir por 32, temos que executar uma divisão de ponto flutuante - o que obviamente leva tempo, mas para fazer o <span class="inline">mod 32</span>, você tem realmente que fazer outra! Se estivéssemos fazendo isto em assembler, na verdade obtemos AMBOS valores em uma divisão, mas você não obtém isto em idiomas de alto nível (bem... não muito frequentemente), e assim você tem que fazer todo o trabalho duas vezes. Isto se soma, especialmente se você estiver fazendo um <span class="notranslate">loop</span> apertado com muitos cálculos como este. O Integer divide usando o bit shifting, como mostrado acima, realmente ajuda a otimizar seu jogo.</p>
  <p>Uma vez que este pode ser um conceito bastante complexo de entender e depois aplicar a situações de programação do mundo real, você pode encontrar abaixo uma série de pequenos exemplos que poderiam ser aplicados a qualquer jogo feito com o <span data-keyref="GameMaker Name">GameMaker</span>.</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Alinhamento de telhas</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Os desenvolvedores do<span data-keyref="GameMaker Name">GameMaker</span> freqüentemente usam a função <span class="inline">place_free()</span>, e então, quando uma colisão for encontrada, tente mover lentamente o <span class="notranslate">object</span> para fora, ou loopando em torno de uma posição <span class="inline">x</span> ou <span class="inline">y</span> enquanto continua a executar essa função, ou usando a função <span class="inline">move_outside_all()</span>.</p>
    <p class="dropspot">Então, qual é a maneira mais rápida de fazer isso? Bem, se usarmos a potência de 2 <span class="notranslate">tiles</span>, então temos um método muito simples que também é rápido como um relâmpago. Se estamos nos movendo para a direita, e nos movemos para um bloco de colisão, então como sabemos que tudo está alinhado a 32, então precisamos também alinhar o <span class="notranslate">sprite</span> a um limite de 32 pixels - de preferência o da esquerda - então o <span class="notranslate">sprite</span> é movido OUT da colisão. Isto é realmente fácil, conhecendo as regras que usamos acima para obter o restante, e sabendo como obter o inverso dos bits, podemos simplesmente fazer isto:</p>
    <p class="code">x = x &amp; ~31;</p>
    <p class="dropspot">Isso mesmo, isso é TUDO o que é preciso para alinhar-se a um limite de 32 pixels. Mudando os 31 podemos nos alinhar a qualquer coisa que quisermos - desde que seja um poder de 2 (isto é o equivalente a dividir por 32, depois multiplicar por 32, removendo assim os bits inferiores).</p>
    <p class="dropspot">Se quiséssemos nos alinhar à direita, então faríamos o acima, mas depois adicionaríamos 32 para movê-lo para o próximo <span class="notranslate">tile</span>. Simples. Tudo isso torna todo o código de colisão monumentalmente mais rápido, e permite que você passe o tempo da CPU onde você realmente precisa.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Chaves e Portas</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Digamos que você tenha um nível com algumas portas, e uma chave para cada uma delas. Como você pode marcar facilmente uma chave para uma porta específica? Bem, normalmente você simplesmente atribuiria uma identificação para a chave e a porta. Então e se você quisesse uma chave para abrir 2 ou 3 portas? Fácil. Você usa uma MÁSCARA. A porta teria um único bit atribuído dessa forma:<br>
       </p>
    <p class="code">door_id = 1; // 0001</p>
    <p class="dropspot">Os outros seriam algo parecidos:<br>
       </p>
    <p class="code">door_id=2; // 0010<br />
      door_id=4; // 0100<br />
      door_id=8; // 1000<br />
      etc...</p>
    <p class="dropspot">Se quiséssemos que a chave abrisse as portas 1 e 3, então a chave teria o valor MASK de 5 (que é 101 em binário). Se executarmos um <span class="inline">AND</span> disso, e ele sair &quot;não zero&quot;, então sabemos que a chave pode abrir a porta. Você também poderia ter chaves que não abrissem nada tendo um MASK de 0. Veja o código abaixo para a verificação propriamente dita:</p>
    <p class="code">if ((key_id &amp; door_id) ! = 0)<br />
      {<br />
          opendoor();<br />
      }</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Contadores em looping</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Digamos que queremos um simples contador de animação, indo de 0 a 15 (já que temos 16 quadros de animação). Normalmente você faria um incremento, e depois faria um cheque em <span class="inline">if</span> para embrulhar o número, mas para este exemplo vamos usar o operador <span class="inline">AND(&amp;)</span>:</p>
    <p class="code">counter = (counter + 1) &amp; 15;</p>
    <p class="dropspot">Como 16 é um poder de 2, podemos reduzir esse número em 1 e usá-lo como máscara, que depois podemos usar para embrulhar nosso contravalor. Se o contador subir de 15 para 16, acabamos com o padrão de bits <span class="inline">10000</span>, e se <span class="inline">AND</span> que com 15 (padrão de bits <span class="inline">01111</span>) acabamos com <span class="inline">00000</span> (simplesmente zero). Isto significa que o código acima é útil para embrulhar valores dentro da faixa de uma potência de 2.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Poder de 2 Verificação</a></p>
  <div class="droptext" data-targetname="drop-down3">
    <p class="dropspot">E se você quisesse verificar se algo era um poder de 2? Bem, aqui está um pequeno truque... Isto retornará <span class="inline">true</span> se o valor dado for um poder de 2:</p>
    <p class="code">function is_pow2(_val)<br />
      {<br />
          return _val &amp; (_val - 1)) == 0;<br />
      }</p>
    <p class="dropspot">Então, se tivéssemos o número 51 (<span class="inline">110011</span>) o que isso faz? Bem, nós temos isto... <span class="inline">110011 &amp; 110010</span> o que obviamente nos deixa com <span class="inline">false</span>, pois sobram muitos pedaços depois do <span class="inline">AND</span>. Se tivéssemos 64 (<span class="inline">1000000</span>), então se torna este... <span class="inline">1000000 &amp; 0111111</span> o <em>que</em> nos deixa 0, então é <span class="inline">true</span>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">Alinhamento do índice</a></p>
  <div class="droptext" data-targetname="drop-down4">
    <p class="dropspot">Aqui está um rápido pedaço de código para alinhar à potência de 2 números. (1,2,4,8,16 e assim por diante). Isto pode ser muito útil para alocação de memória, ou certificar-se de escrever os dados nos limites adequados. Neste exemplo, <span class="inline">_val1</span> precisa ser alinhado a <span class="inline">_val2</span> bytes, onde <span class="inline">_val2</span> é um poder de 2 números. Esta pequena função arredonda para cima até o próximo limite do número desejado.</p>
    <p class="code">function align_pow2(_val1, _val2)<br />
      {<br />
          return _val1 + (_val2 - 1)) &amp; ~(_val2 - 1);<br />
      }</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Voltar: <a href="Additional_Information.htm">Informações adicionais</a></div>
        <div style="float:right">A seguir: <a href="Type_Tables.htm">Tabelas de tipo</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Todos os direitos reservados</span></h5>
  </div>
  <!-- KEYWORDS
Bitwise Operators
-->
  <!-- TAGS
bitwise_operators
-->
</body>
</html>