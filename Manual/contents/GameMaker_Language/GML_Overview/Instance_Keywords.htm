<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Palavras-chave da instância</title>
    <meta name="generator" content="Adobe RoboHelp 2020" />
    <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
    <script src="../../assets/scripts/main_script.js"></script>
    <meta name="rh-authors" content="Mark Alexander" />
    <meta name="topic-comment" content="Page outlining the different instance &quot;keywords&quot;" />
    <meta name="rh-index-keywords" content="Instance Keywords,noone,self,other,all" />
    <meta name="search-keywords" content="self,all,noone,other,instance keywords" />
  </head>
  <body><!--<div class="body-scroll" style="top: 150px;">-->
    <h1>Palavras-chave da instância</h1>
    <p>Para facilitar certas coisas no <span data-keyref="GameMaker Name">GameMaker</span>, você pode usar uma das várias <b>palavras-chave de instância</b> em seu código (seja <span class="notranslate">GML</span> ou <span class="notranslate">GML</span> Visual). Estas palavras-chave são usadas principalmente para identificar instâncias - e em alguns casos <span class="notranslate">structs</span> - sob diferentes situações, e cada uma delas é explicada no texto abaixo.</p>
    <p>Observe que todas as palavras-chave dadas são representadas por <strong>valores inteiros negativos</strong> internamente, portanto, deve-se ter cuidado ao atribuir ou verificar os valores das variáveis contra ou com essas palavras-chave, pois você pode obter resultados inesperados mais tarde, já que o <span data-keyref="GameMaker Name">GameMaker</span> interpreta o valor que você usou como algo diferente. Você também deve observar que o uso dos valores inteiros diretamente ao invés das palavras-chave em seu código <b>não</b> é <b>recomendado</b> e pode causar problemas mais tarde.</p>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span class="inline">self</span></a></p>
    <div class="droptext" data-targetname="drop-down">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Palavra-chave</th>
            <th>Descrição</th>
            <th>valor</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">self</span></td>
            <td>A instância/estrutura que está executando o bloco de código atual.</td>
            <td><span class="notranslate">   -1</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot"><span class="inline">self</span> pode ser usado para identificar o atual <span class="notranslate">struct</span> ou instância que está no escopo do atual bloco de código. Por exemplo:</p>
      <p class="code">var val = 100;
        <br/>
        with (instance_create_layer(x, y, &quot;Instances&quot;, obj_Fire))
        <br/>
        {
        <br/>
        self.val = val;
        <br/>
        }</p>
      <p class="dropspot">Neste exemplo, você pode ver que temos uma variável <i>local</i> chamada <span class="inline">val</span> e queremos que ela defina a variável de <i>instância</i> com o mesmo nome na recém-criada instância <span class="notranslate">object</span>. Para identificar corretamente a variável de instância e dizer ao <span data-keyref="GameMaker Name">GameMaker</span> para defini-la na instância chamando o bloco de código, usamos a palavra-chave <span class="inline">self</span>. Na maioria dos casos, você também pode usar a variável de instância incorporada <span class="inline">id</span> ao invés de <span class="inline">self</span>, mas <span class="inline">self</span> oferece certos benefícios. Para começar, é mais rápido para o compilador identificar a instância (ou <span class="notranslate">struct</span>) usando <span class="inline">self</span> em vez de <span class="inline">id</span>, já que o valor <span class="inline">id</span> passa pela tabela de pesquisa da instância enquanto <span class="inline">self</span> não o faz. Em segundo lugar, para as pessoas que fazem <span class="notranslate">extensions</span>, é muito útil assegurar o escopo correto das variáveis, já que é possível que um projeto que usa <span class="notranslate">extension</span> possa ter uma variável de escopo global ou algo com o mesmo nome que uma variável no <span class="notranslate">extension</span>.</p>
      <p class="note"><strong>NOTA</strong>: A palavra-chave <span class="inline">self</span> <strong>não é um </strong>atalho para o valor real de identificação de uma instância ou <span class="notranslate">struct</span> e só deve ser usada no contexto explicado acima. Se você precisar do <strong>valor de </strong>identificação de uma instância, então você precisa usar <span class="inline">self.id</span>, por exemplo:</p>
      <p class="code">var myID = id;
        <br/>
        with (all)
        <br/>
        {
        <br/>
        if self.id == myID
        <br/>
        {
        <br/>
        // do something
        <br/>
        }
        <br/>
        }</p>
      <p class="dropspot">Vale ressaltar também que <span class="inline">self</span> também pode ser utilizado dentro de <a href="Structs.htm">estruturas</a> - sob circunstâncias muito específicas - para referenciar variáveis de membros para o <span class="notranslate">struct</span>.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span class="inline">other</span></a></p>
    <div class="droptext" data-targetname="drop-down1">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Palavra-chave</th>
            <th>Descrição</th>
            <th>valor</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">other</span></td>
            <td>A outra instância envolvida em um evento de colisão, em uma função <span class="inline">with</span> ou em uma função.</td>
            <td><span class="notranslate">   -2</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">A palavra-chave especial <span class="inline">other</span> tem múltiplas maneiras de ser usada para fazer referência a uma instância específica (e em alguns casos, uma <span class="notranslate">struct</span>): pode ser usada em uma declaração <span class="inline">with</span> (explicada <a href="Language_Features/with.htm">aqui</a>), em um <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">evento de colisão</a>, ou em uma função. Esta seção vai explicar os dois últimos casos de uso.</p>
      <p class="dropspot">Observe que em eventos que não sejam o evento de colisão, quando fora de qualquer chamada de função e <span class="inline">with()</span> blocos, <span class="inline">other</span> simplesmente retorna o <span class="notranslate">struct</span> para a instância atual.</p>
      <h2 class="dropspot">Evento de colisão</h2>
      <p class="dropspot">Um evento de colisão só pode acontecer entre <strong>duas </strong>instâncias. Você <i>pode</i> ter múltiplas colisões entre múltiplas instâncias, mas todas elas são resolvidas pelo <span data-keyref="GameMaker Name">GameMaker</span> em uma base 1 contra 1, com a instância &quot;self&quot; que tem o evento de colisão e a &quot;outra&quot; instância que está colidindo com ele.</p>
      <p class="dropspot">Imagine que você tem uma instância de jogador, múltiplas instâncias inimigas e múltiplas instâncias de bala que o inimigo pode atirar em você. Você pode atribuir a cada inimigo uma única instância de bala, mas com uma variável de dano diferente atribuída aleatoriamente a ela quando criada, por exemplo:</p>
      <p class="code">var bullet;
        <br/>
        bullet = instance_create_layer(x, y, &quot;Bullets&quot;, obj_Bullet);
        <br/>
        bullet.damage = 5 + irandom(5);
        <br/>
        bullet.speed = 8;
        <br/>
        bullet.direction = point_direction(x, y, obj_Player.x, obj_Player.y);</p>
      <p class="dropspot">Você pode ver como definimos suas variáveis usando a notação de pontos, conforme descrito na seção sobre <a href="Addressing_Variables_In_Other_Instances.htm">endereçamento de variáveis em outras instâncias</a>. Isto dará a cada instância de bala um valor de dano diferente, mas como o jogador detectará o dano que tem de suportar quando é atingido por uma bala?</p>
      <p class="dropspot">Para isso, o jogador precisará ter um evento de colisão com <span class="inline">obj_Bullet</span>, e dentro desse evento usar <span class="inline">other</span> para ler variáveis da instância da bala colidida:</p>
      <p class="code">hp -= other.damage;
        <br/>
        if hp &lt;= 0 instance_destroy();</p>
      <p class="dropspot">O código acima deduzirá o valor armazenado na variável &quot;damage&quot; da <i>outra</i> instância da variável &quot;hp&quot; do jogador, então verificará se o &quot;hp&quot; é menor ou igual a 0. Se for, então destruirá a instância do jogador. Observe que a outra instância deve ter a variável sendo verificada ou um erro será atirado.</p>
      <p class="note"><strong>NOTA</strong>: O evento Collision é o único evento que tem um significado especial para a palavra-chave <span class="inline">other</span>. Em todos os outros eventos e <span class="notranslate">scripts</span>, o comportamento do <span class="inline">other</span> será definido pelo contexto em que está sendo usado (como um bloco <span class="inline">with() </span>, uma função, uma declaração <span class="notranslate">struct</span>, etc.).</p>
      <p class="dropspot">Você pode atribuir valores a variáveis, ou mesmo criar novos, usando <span class="inline">other</span> no evento de colisão, como este:</p>
      <p class="code">// add ten to the other instance &quot;mana&quot; variable
        <br/>
        other.mana += 10;
        <br/>
        // set the other instance variable &quot;hit&quot; to true, creating the variable if it doesn&#39;t already exist
        <br/>
        other.hit = true;</p>
      <h2 class="dropspot">Declaração de estruturas</h2>
      <p class="dropspot">Quando usado dentro de uma declaração <span class="notranslate">struct</span>, <span class="inline">other</span> refere-se à instância que está inicializando a estrutura:</p>
      <p class="code">var _struct =
        <br/>
        {
        <br/>
        parent_instance : other
        <br/>
        }
        <br/>
        <br/>
        show_debug_message(_struct.parent_instance == self);
        <br/>
        // This prints &#39;1&#39; (true) meaning that both sides refer to the same instance </p>
      <p class="dropspot">Entretanto, você não precisa usar <span class="inline">other</span> para ler variáveis da instância, já que quaisquer variáveis que você referir diretamente serão lidas a partir do escopo daquela instância, conforme descrito <a href="Structs.htm#inst_in_struct">nesta seção</a> do manual. Você só precisaria usar isto se quisesse armazenar uma referência à <span class="notranslate">struct</span> daquela instância.</p>
      <h2 class="dropspot">Método de instância</h2>
      <p class="dropspot">Usando <span class="inline">other</span> dentro de outra instância <a href="Method_Variables.htm"><span class="notranslate">method</span></a> refere-se à instância que chamou esse método.</p>
      <p class="dropspot">Por exemplo, digamos que <span class="inline">Object2</span> tem um método que faz referência a <span class="inline">self</span> e <span class="inline">other</span>. Este método é então chamado em <span class="inline">Object1</span>. Como o método foi criado em <span class="inline">Object2</span>, ele está <strong>vinculado</strong> a ele e sempre usará a instância <span class="inline">Object2</span> como o &quot;self&quot;, não importa a instância que o chame. Em tal caso, a instância de chamada torna-se <span class="inline">other</span>.</p>
      <p class="code">// In Object2
        <br/>
        my_method = function()
        <br/>
        {
        <br/>
        show_debug_message(object_get_name(self.object_index));
        <br/>
        show_debug_message(object_get_name(other.object_index));
        <br/>
        }
        <br/>
        <br/>
        // In Object1
        <br/>
        Object2.my_method(); </p>
      <p class="dropspot">Isto faria com que a instância imprimisse primeiro seu próprio nome <span class="notranslate">object</span> (&quot;Object2&quot;) e depois o nome <span class="notranslate">object</span> da instância de chamada (&quot;Object1&quot;).</p>
      <p class="dropspot">O mesmo se aplicará a um método que está vinculado a um <span class="notranslate">struct</span>.</p>
      <h2 class="dropspot">Função Construtora</h2>
      <p class="dropspot">Quando usado dentro de uma função de construtor, <span class="inline">other</span> referenciará a instância que está chamando essa função, porém isso não é recomendado para uso geral, pois qualquer dado externo que um construtor precise usar deve ser passado como argumentos.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span class="inline">all</span></a></p>
    <div class="droptext" data-targetname="drop-down2">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Palavra-chave</th>
            <th>Descrição</th>
            <th>valor</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">all</span></td>
            <td>Todas as instâncias atualmente ativas no <span class="notranslate">room</span>.</td>
            <td><span class="notranslate">   -3</span></td>
          </tr>
        </tbody>
      </table>
      <p> </p>
      <p class="dropspot">Esta palavra-chave é usada para dizer ao <span data-keyref="GameMaker Name">GameMaker</span> que uma função deve ser aplicada, ou para verificar todas as instâncias ativas dentro de um <span class="notranslate">room</span> (as instâncias desativadas não serão verificadas ou acessadas). Você <b>não pode</b> usar <span class="inline">all</span> para acessar ou definir variáveis em outras instâncias usando o método de ponto (veja <a href="Addressing_Variables_In_Other_Instances.htm">aqui</a>), mas você <strong>pode </strong>usá-lo ao chamar <a href="Language_Features/with.htm"><span class="inline">with()</span></a>por exemplo:</p>
      <p class="code">with (all)
        <br/>
        {
        <br/>
        speed = 0;
        <br/>
        }</p>
      <p class="dropspot">O código acima definirá a velocidade de todas as instâncias no <span class="notranslate">room</span> para 0. Você também pode usar <span class="inline">all</span> dentro das funções para direcionar ou verificar todas as instâncias no <span class="notranslate">room</span>, por exemplo:</p>
      <p class="code">// Check a point for any active instance in the room
        <br/>
        inst = instance_position(mouse_x, mouse_y, all);
        <br/>
        <br/>
        // Check all instances for a collision along a line
        <br/>
        if collision_line(x, y, mouse_x, mouse_y, all, false, true) {}
        <br/>
        <br/>
        // Add all instances in the room into a motion planning grid
        <br/>
        mp_grid_add_instances(grid, all, false); </p>
      <p class="dropspot"><span class="inline">all</span> é uma palavra-chave muito útil e pode ser usada em inúmeras situações dentro de seu código e ações, muitas vezes reduzindo a quantidade de código que você precisa escrever para alcançar um efeito desejado.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span class="inline">noone</span></a></p>
    <div class="droptext" data-targetname="drop-down3">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Palavra-chave</th>
            <th>Descrição</th>
            <th>valor</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">noone</span></td>
            <td>Sem nenhum exemplo.</td>
            <td><span class="notranslate">   -4</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">Pode parecer estranho, mas muitas vezes, ao programar seus jogos, você encontrará a necessidade de verificar se não há casos encontrados em um local, ou em uma colisão, etc... Nesses casos, você usaria esta palavra-chave para verificar se não há nada, algo como isto:</p>
      <p class="code">if instance_nearest(x, y, obj_enemy) != noone
        <br/>
        {
        <br/>
        //do something as there is an enemy instance near
        <br/>
        }</p>
      <p class="dropspot">Neste exemplo, a função <span class="inline">instance_nearest()</span> retornará ou <span class="inline">noone</span> ou a identificação única da instância encontrada mais próxima. Basicamente, a qualquer momento que você precise verificar por uma instância, você pode esperar obter ou <span class="inline">noone</span> ou uma identificação única da instância devolvida.</p>
      <p class="dropspot"> </p>
    </div>
    <p> </p>
    <p> </p>
    <p> </p>
    <div class="footer">
      <div class="buttons">
        <div class="clear">
          <div style="float:left">Voltar: <a href="GML_Overview.htm">Visão geral da GML</a></div>
          <div style="float:right">A seguir: <a data-xref="{title}" href="Evaluation_Order.htm">Ordem de avaliação</a></div>
        </div>
      </div>
      <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Todos os direitos reservados</span></h5>
    </div>
    <!-- KEYWORDS
Instance Keywords
self
all
noone
other
--><!-- TAGS
instance_keywords
--></body>
</html>