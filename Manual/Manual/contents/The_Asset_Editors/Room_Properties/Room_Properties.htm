<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Propriedades dos quartos</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the different room properties" />
  <meta name="rh-index-keywords" content="Rooms - Room Settings" />
  <meta name="search-keywords" content="room settings,cameras,viewports,room size,room properties,view cameras" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Propriedades dos quartos</h1>
  <p><img>A seção de propriedades <span class="notranslate">Room</span> é onde você pode definir a alternância de herança para as configurações, mudar opções como persistência, o tamanho da sala e gerenciar os viewports.</p>
  <h2>Persistente</h2>
  <p>Normalmente, quando você deixa um <span class="notranslate">room</span> e retorna ao mesmo <span class="notranslate">room</span> mais tarde, esse <span class="notranslate">room</span> é reajustado para suas configurações iniciais. Isso normalmente é bom para a maioria dos jogos, mas pode não ser o que você quer, por exemplo, em um RPG ou qualquer jogo não linear, onde você quer ir e vir entre <span class="notranslate">rooms</span> e fazer com que eles sejam do jeito que você os deixou da última vez. Ao marcar a caixa com o rótulo <strong>Persistente </strong>, você fará exatamente isso. O status <span class="notranslate">room</span> será lembrado e quando você retornar a ele mais tarde, será exatamente o mesmo que o deixou, sendo reiniciado apenas para o estado inicial quando o jogo for reiniciado. Note que há <em>uma </em>exceção a isto - se você marcou certo <span class="notranslate">objects</span> como sendo persistente, instâncias deste <span class="notranslate">object</span> <em>não </em>ficarão no <span class="notranslate">room</span> mas passarão para o próximo <span class="notranslate">room</span>.</p>
  <h2 id="clear_display_buffer">Buffer de exposição transparente</h2>
  <p>Depois disso, você tem a opção de <strong>limpar o Buffer de exibição</strong>. Esta opção, quando marcada, preenche o <a class="glossterm" data-glossterm="buffer de exibição" href="#">buffer de exibição</a> com uma cor antes de desenhar qualquer outra coisa para uma determinada moldura. Se você souber que suas visões estarão cobrindo a tela inteira o tempo todo ou que você tem uma tela cheia, um fundo opaco sendo desenhado, então você pode desmarcar isto, o que poupa um redesenho e assim ajuda a otimizar seu jogo.</p>
  <p>Entretanto, se você tiver várias vistas que, quando na tela deixam espaços abertos, ou seu fundo tem peças transparentes - você pode verificar isso para que quaisquer áreas vazias sejam preenchidas com a cor do desenho de sua escolha. Atualmente, esta cor só pode ser definida através de código usando <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/The_Game_Window/window_set_colour.htm"><span class="inline">window_set_colour()</span></a>.</p>
  <p class="note"><span class="note">OBSERVAÇÃO</span> Se você estiver usando correção automática da relação de aspecto (como definido nas <a href="../../Settings/Game_Options.htm">Opções de Jogo</a>), então você deve <strong>sempre </strong>ter isso verificado, caso contrário você pode obter efeitos estranhos sobre a &quot;caixa de correio&quot; na qual seu jogo é atraído. Se você não usar esta opção, então você pode desmarcá-la e obter um pequeno aumento no desempenho de seu jogo (especialmente perceptível em <span class="notranslate">Android</span> e outras plataformas móveis).</p>
  <h2>Largura, Altura e outras opções</h2>
  <p>Um <span class="notranslate">room</span> tem que ter um tamanho e isto é definido pelos valores que você digita para sua largura e altura em pixels.</p>
  <p>Você pode então adicionar o <strong>Código de Criação</strong>, caso você o solicite. O código de criação é adicionado a partir do botão na parte inferior (junto com a chave <span class="notranslate">inherit</span> para dizer se o <span class="notranslate">room</span> deve ou não <span class="notranslate">inherit</span> é código de criação), e se você clicar nele, abrirá um código ou editor visual. Este editor permite que você insira funções/ações e códigos que serão executados no <em>início </em>do <span class="notranslate">room</span>, após o evento de criação de todas as instâncias, mas antes do evento de início do <span class="notranslate">room</span> (para mais informações sobre a ordem do evento, por favor, veja <a href="../Object_Properties/Event_Order.htm">aqui</a>). Este código será executado toda vez que você entrar no <span class="notranslate">room</span>, a menos que o <span class="notranslate">room</span> seja sinalizado como persistente, neste caso, ele só será executado uma vez quando o <span class="notranslate">room</span> for inserido pela primeira vez, mas não em visitas subseqüentes ao <span class="notranslate">room</span>.</p>
  <h2 id="creation_order">Ordem de criação da instância</h2>
  <p>O botão final no site <span class="notranslate">Room</span> Propriedades permite abrir a janela de <strong>Ordem de Criação de Instância</strong>:</p>
  <p><img>Esta janela lista todas as instâncias no <span class="notranslate">room</span> na ordem em que serão criadas (de cima para baixo). Se você precisar criar uma instância específica antes de qualquer outra, basta clicar em <img> e arrastá-la para a posição que você precisar. Note que as instâncias serão criadas na ordem dada de cima para baixo da lista.</p>
  <div data-conref="../../assets/snippets/Instance_creation_order_warning.hts"> </div>
  <p> </p>
  <p> </p>
  <h1>Câmeras e Viewports</h1>
  <p>O próximo conjunto de propriedades para o <span class="notranslate">room</span> que você pode definir são as relativas à sala <strong>Câmera</strong> e <strong>Viewports</strong>. As vistas da câmera dão um mecanismo para desenhar diferentes partes de seu <span class="notranslate">room</span> em diferentes lugares na tela, ou para desenhar apenas uma parte de seu <span class="notranslate">room</span> para cobrir a tela inteira. Por exemplo, na maioria dos jogos de plataforma, a vista da câmera segue o personagem principal, pois, se você pudesse ver o nível inteiro na tela, seu personagem seria muito pequeno para ver e não haveria surpresas para o jogador. A visão de câmera também pode ser usada em jogos multi-jogador ou jogos cooperativos, pois permitem criar uma configuração de tela dividida na qual em uma parte da tela você vê um jogador e em outra parte você vê o outro jogador. Tudo isso pode ser facilmente alcançado no <span data-keyref="GameMaker Name">GameMaker</span> usando as visões de câmera.</p>
  <p><img>No topo das propriedades de visualização você pode ativar ou desativar a herança de visualização, então há uma caixa rotulada <strong>Enable Viewports</strong>. Isto <em>deve ser marcado</em> antes que qualquer uma das vistas da câmera possa ser usada em seu jogo.</p>
  <p class="note"><span class="note">NOTA</span> Você pode ativar ou desativar a herança para as três configurações principais de viewport e, em seguida, você pode ativar ou desativar a herança para cada visualização individual da câmera.</p>
  <p>A próxima caixa de seleção é a que diz <strong>Clear Viewport Background</strong>, que é semelhante à opção <a href="#clear_display_buffer">Clear Display Buffer</a> dada acima, mas especificamente para viewports. Quando ativado, ele limpa a <a class="glossterm" data-glossterm="superfície de aplicação" href="#">superfície de aplicação</a> com a cor da janela antes de desenhar cada moldura. Isto assegura que você não veja nenhum gráfico não intencional através de áreas transparentes em seu fundo, tais como o conteúdo de qualquer quadro anterior; portanto, é importante ativar esta opção (juntamente com &quot;<strong>Habilitar Viewports</strong>&quot;) se seu fundo contiver alguma transparência.</p>
  <p>A visão da câmera é definida por dois conjuntos diferentes de valores, a própria visão da câmera e a porta na tela onde esta visão deve ser desenhada. Isto pode às vezes causar confusão, então vamos explicar isto um pouco antes de explicar como definimos cada um deles:</p>
  <ul class="colour">
    <li><strong>A Câmera</strong>: Um ponto dentro do <span class="notranslate">room</span> que será usado para definir como o <span class="notranslate">room</span> é exibido na tela (este é um ponto abstrato no editor <span class="notranslate">room</span> e sua posição é definida automaticamente com base nas configurações de visualização e porta de visualização)</li>
    <li><strong>A Vista</strong>: O que a câmera vê, com base na posição, projeção e rotação da câmera</li>
    <li><strong>A Porta de Vista</strong>: A área da tela física onde a visão da câmera será exibida.</li>
  </ul>
  <p><img>Assim, por exemplo, isto significa que você pode ter uma visão de câmera 640x480 em seu <span class="notranslate">room</span>, e então definir a porta para 320x240, que exibirá a visão reduzida para aquela porta de tamanho na tela, e você também pode fazer o mesmo e definir a visão para um valor menor e a porta para maior, fazendo com que a imagem seja escalada para se ajustar ao tamanho da porta e ser exibida na tela maior do que ela é. Desta forma, você pode manter um tamanho de tela (porta) enquanto muda a visão da câmera para exibir mais ou menos do <span class="notranslate">room</span> na mesma área da tela.</p>
  <p>A visão da câmera é sempre definida como uma área retangular no <span class="notranslate">room</span>, onde se especifica a posição do canto superior esquerdo, a largura e a altura desta área. Em seguida, você deve especificar onde esta área é mostrada na janela na tela, definindo a porta de visualização, onde novamente você especifica a posição do canto superior esquerdo e o tamanho (note que qualquer coisa diferente de 0,0 para o canto superior esquerdo pode dar resultados estranhos). Você pode ter mais de uma porta e elas podem se sobrepor, caso em que são desenhadas na ordem indicada, uma em cima da outra.</p>
  <p>Por favor, perceba que a área total da tela é <em>sempre definida como uma área retangular</em>, de modo que suas portas, mesmo quando compensadas, formarão um retângulo, com quaisquer espaços vazios sendo preenchidos pela cor da janela do <a class="glossterm" data-glossterm="buffer de exibição" href="#">buffer de exibição</a>, o que significa que nestas circunstâncias você deve sempre ter o <strong>Clear Display Buffer</strong> verificado ou então você terá artefatos estranhos desenhados nos espaços entre as portas. A imagem abaixo ilustra isto, onde há duas portas de visualização em offset visíveis, mas elas fazem uma janela quadrada, e &quot;por baixo&quot; há linhas sendo desenhadas para o buffer de visualização:</p>
  <p><img>As câmeras também têm a opção <strong>Object Following </strong>. Isto é para quando você quiser que a câmera &quot;siga&quot; (ou seja: mantenha a visão focalizada) um certo <span class="notranslate">object</span>. Para isso você deve clicar <img> no ícone do menu e selecionar um <span class="notranslate">object</span> da lista que aparece (se houver múltiplas instâncias deste <span class="notranslate">object</span> no <span class="notranslate">room</span>, apenas uma delas é seguida pela câmera).</p>
  <p>O comportamento normal de uma câmera é se mover apenas quando a instância sendo seguida se aproxima demais de uma zona &quot;tampão&quot; que faz um limite invisível ao redor da borda da vista. Esta zona pode ser definida por você usando os valores de <strong>Borda Horizontal </strong>e <strong>Borda Vertical </strong>, assim - por exemplo - definir estes valores para 64 significará que a vista não começará a se mover e seguirá o caractere até atingir 64 pixels a partir da borda da vista.</p>
  <p>Finalmente você pode indicar a <strong>velocidade </strong> <strong>horizontal</strong> e <strong>vertical </strong>em que a câmera se move quando o caractere atinge a zona <span class="notranslate">buffer</span>, e isto tem um valor padrão de -1. Este valor padrão é basicamente &quot;instantâneo&quot; e significa que no momento em que a instância seguinte estiver fora da borda horizontal ou borda vertical <span class="notranslate">buffer</span> zona, a vista saltará para sua posição atual. Agora, isto nem sempre é o que você quer e, portanto, você pode definir a velocidade de rolagem vertical e horizontal para a câmera, ajustando os valores para algo diferente de -1. Note que um valor de 0 fará com que a vista não se mova de forma alguma, e qualquer outro valor positivo é quantos pixels ela se moverá em qualquer quadro, portanto, ajustando a velocidade horizontal para 5 terá a vista seguindo o <span class="notranslate">object</span> a 5 pixels por quadro horizontalmente.</p>
  <p> </p>
  <p> </p>
  <h1>Física das salas</h1>
  <p>Antes de poder usar as funções físicas embutidas em seus jogos, você deve dizer ao <span data-keyref="GameMaker Name">GameMaker</span> que o <span class="notranslate">room</span> é um jogo de física <span class="notranslate">room</span>. Para fazer isso, você deve marcar a opção de <strong>Habilitar Física </strong>no topo da seção de <em>Física de Salas</em> (você também pode alternar a herança desta seção independentemente do resto das configurações do <span class="notranslate">room</span> ). Uma vez feito isso, você pode continuar a configurar as propriedades do mundo da física, que são algumas propriedades básicas que você deve ter pré-definidas antes que seu <span class="notranslate">room</span> permita que as instâncias da física funcionem como tal. Para um controle mais preciso sobre o mundo, você pode usar código (veja as <a href="../../GameMaker_Language/GML_Reference/Physics/Physics.htm">Funções Físicas</a> para mais informações).</p>
  <p><img>A próxima coisa que você deve fazer é configurar a <strong>Gravidade </strong>do mundo. A força e a direção desta é calculada como um <a class="glossterm" data-glossterm="vetor" href="#">vetor</a> da posição x/y que você estabelece em torno de um (0, 0) ponto. Assim, um x de 0 e um y de 1 definirá a direção da gravidade como sendo <em>para baixo </em>com uma força de 1 metro por segundo (para uma explicação mais detalhada veja - <a href="../../GameMaker_Language/GML_Reference/Physics/The_Physics_World/The_Physics_World.htm">O Mundo Físico</a>).</p>
  <p>Finalmente, você deve definir a relação de<strong> Pixels para Medidores</strong> para que o <span data-keyref="GameMaker Name">GameMaker</span> use como base para todos os seus cálculos físicos. Isto porque as funções físicas funcionam em medições do mundo real, e é por isso que devemos definir este valor, e você vai querer ajustar esta configuração até que o tamanho médio dos pixels do <span class="notranslate">objects</span> que você está usando se traduza aproximadamente em física simulada <span class="notranslate">objects</span> de um tamanho apropriado.</p>
  <p>Deve-se observar que habilitar a física em um <span class="notranslate">room</span> significa que todas as instâncias na sala <em>devem usar os coeficientes e variáveis físicas para se mover</em>. Basicamente, você tem o movimento &quot;tradicional&quot;, onde você pode definir a posição X/Y de uma instância ou definir sua velocidade e direção, e então você tem o movimento &quot;físico&quot;, que requer forças físicas e impulsos para se mover. Estes sistemas são <strong>mutuamente exlusivos</strong>, e você não pode mover uma instância física usando funções não-físicas e não pode mover uma instância não-física usando as funções físicas.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Voltar: <a href="../Rooms.htm">O Editor <span class="notranslate">Room</span> </a></div>
        <div style="float:right">A seguir: <a href="Room_Inheritance.htm">Herança de Quarto</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Todos os direitos reservados</span></h5>
  </div>
  <!-- KEYWORDS
Room Properties
View Ports
View Cameras
-->
  <!-- TAGS
rooms_properties
-->
</body>
</html>